#!/usr/bin/env ruby

require "puavo"
require 'net/https'
require "socket"
require 'openssl'
require 'highline/import'

private_key = "/etc/puavo/certs/host.key"
certificate_file = "/etc/puavo/certs/host.crt"

def puavo_server
  PUAVO_ETC.resolve_puavo_url
end

def hostname
  # FIXME lucid? quantal?
  PUAVO_ETC.hostname
  # Socket.gethostname
end

HighLine.say "\nUpdate certificate for Puavo device\n\n"
HighLine.say "Puavo server: #{ puavo_server }"
@username = HighLine.ask("Username: [admin] ").strip
@username = "admin" if @username.match(/^\n$/)
@password = HighLine.ask("Password: ") { |q| q.echo = '*' }.strip

# Read old private key
key_pem = File.read private_key
@key = OpenSSL::PKey::RSA.new key_pem
@csr = OpenSSL::X509::Request.new
@csr.version = 0
@csr.public_key = @key.public_key

begin
  server_uri = URI(puavo_server)
  @http              = Net::HTTP.new(server_uri.host, server_uri.port)
  @http.use_ssl      = server_uri.scheme == "https"
  @http.ca_path      = '/etc/ssl/certs'
  @http.verify_mode  = OpenSSL::SSL::VERIFY_PEER
  @http.verify_depth = 5
  request = Net::HTTP::Post.new( "/api/v2/hosts/sign_certificate",
                                 { 'Content-Type' => 'application/json' })
  request.basic_auth(@username, @password)
  response = @http.request( request,
                            { "hostname" => hostname,
                              "host_certificate_request" => @csr.to_pem }.to_json )
rescue EOFError
  puts "Can't connect to puavo server (#{ puavo_server })"
  exit
end

if response.code.to_i != 200
  puts "Unable to sign certificate"
  begin
    puts JSON.parse(response.body)
  rescue Exception => e
    puts "Unable to parse response! (#{ e })"
  end
  exit
end

host = JSON.parse(response.body)
if host["userCertificate"]
  puts "Update host certificate (/etc/puavo/certs/host.crt)"
  File.open(certificate_file, 'w', 0400) { |f| f.print host["userCertificate"] }
end
