#!/usr/bin/env ruby1.9.1

require "digest/sha1"
require "fileutils"
require "json"
require "net/http"
require "optparse"
require "puavo"
require "uri"

# puavo lib must loaded before rest-client because rest-client is bundled into
# puavo lib

options = {}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{ File.basename(__FILE__) } [options] [target]"

  opts.on("-s", "--server [SERVER]", "Puavo REST server URI") do |server|
    options[:server] = server
  end

  opts.on("-h", "--hostname [HOSTNAME]", "Client hostname") do |hostname|
    options[:hostname] = hostname
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

end
parser.parse!

def check_call(cmd)
  res = `#{ cmd }`
  if $?.success?
    return res.chomp
  else
    raise "Failed to execute '#{ cmd }'"
  end
end

options[:target] = ARGV[0] || "/state/external_files"
options[:server] ||= check_call "puavo-resolve-api-server"
options[:hostname] ||= PUAVO_ETC.hostname

def read_current_files(dirpath)
  Dir.entries(dirpath).map do |name|
    begin
      File.open(File.join(dirpath, name), "rb") do |f|
        sha1 = Digest::SHA1.new

        while data = f.read(512)
          sha1.update(data)
        end

        {
          "name" => name,
          "data_hash" => sha1.hexdigest
        }
      end
    rescue Errno::EISDIR
    end
  end.compact
end

class ExternalFiles
  def initialize(base_uri, username, password)
    @base_uri = base_uri
    @username = username
    @password = password

    cert_data = File.read('/etc/puavo/certs/host.crt')
    @cert = OpenSSL::X509::Certificate.new(cert_data)

    key_data = File.read('/etc/puavo/certs/host.key')
    @key = OpenSSL::PKey::RSA.new(key_data)
  end

  def get(subpath)
    uri = URI.parse("#{ @base_uri }#{ subpath }")

    http             = Net::HTTP.new(uri.host, uri.port)
    # http.ca_file     = '/etc/puavo/certs/rootca.pem' # XXX
    http.cert        = @cert
    http.key         = @key
    http.use_ssl     = true
    http.verify_mode = OpenSSL::SSL::VERIFY_PEER

    request = Net::HTTP::Get.new(uri.request_uri)
    request.basic_auth(@username, @password)

    http.request(request).body
  end

  def data(name)
    get("/#{ name }")
  end

  def index
    JSON.parse(get(''))
  end
end

def main(options)
  FileUtils.mkdir_p(options[:target])
  current_files = read_current_files(options[:target])

  ef_root = URI.join(options[:server],
		     "/v3/devices/#{ options[:hostname] }/",
		     'external_files').to_s

  puts "Connecting to #{ ef_root }"

  ef = ExternalFiles.new(ef_root, PUAVO_ETC.ldap_dn, PUAVO_ETC.ldap_password)
  ef.index.each do |meta|
    file_path = File.join(options[:target], meta["name"])

    if current_files.include?(meta)
      puts "OK #{ file_path } #{ meta["data_hash"] }"
      next
    end

    File.open(file_path, "w") do |f|
      data = ef.data(meta["name"])
      puts "Writing #{ file_path } #{ meta["data_hash"] }"
      f.write(data)
    end
  end
end

if __FILE__ == $0
  main(options)
end
